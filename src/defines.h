#ifndef INCLUDED_DEFINES_H
#define INCLUDED_DEFINES_H

/** \file defines.h 
    \brief Constant, flag and macro definitions 

 * Version #, grid, etc. size, MAX_* figures, limits, constants, critical
 * values, etc. for every characteristic of Angband.  Indexes, text locat-
 * ions, list of summonable monsters. Feature, artifact and ego-item codes.
 * Object tval (kind) and sval (specific type) with sval limitations.
 * Monster blow constants, function, player, object and monster bit flags
 * (translation from code to flag).  Definitions of options and object in-
 * scriptions.
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This software may be copied and distributed for educational, research,
 * and not for profit purposes provided that this copyright and statement
 * are included in all such copies.  Other copyrights may also apply.
 *


 *
 * Do not edit this file unless you know *exactly* what you are doing.
 * 
 * Some of the values in this file were chosen to preserve game balance,
 * while others are hard-coded based on the format of old save-files, the
 * definition of arrays in various places, mathematical properties, fast
 * computation, storage limits, or the format of external text files.
 *
 * Changing some of these values will induce crashes or memory errors or
 * savefile mis-reads.  Most of the comments in this file are meant as
 * reminders, not complete descriptions, and even a complete knowledge
 * of the source may not be sufficient to fully understand the effects
 * of changing certain definitions.
 *
 * Lastly, note that the code does not always use the symbolic constants
 * below, and sometimes uses various hard-coded values that may not even
 * be defined in this file, but which may be related to definitions here.
 * This is of course bad programming practice, but nobody is perfect...
 *
 * For example, there are MANY things that depend on the screen being
 * 80x24, with the top line used for messages, the bottom line being
 * used for status, and exactly 22 lines used to show the dungeon.
 * Just because your screen can hold 46 lines does not mean that the
 * game will work if you try to use 44 lines to show the dungeon.
 *
 * You have been warned.
 */

/* Hack */
#include "tvalsval.h"

/**
 * Name of the version/variant
 */
#define SAVEFILE_NAME  "FAAN"


/**
 * Current version string - according to FAangband reckoning.
 */
/*
#ifdef BUILD_ID
#define VERSION_STRING	"1.4.1 (" BUILD_ID ")"
#endif
*/

/*
 * Current FAangband version numbers.
 */
#define VERSION_MAJOR	1
#define VERSION_MINOR	4
#define VERSION_PATCH	1
#define VERSION_EXTRA	0

/**
 * Number of grids in each block (vertically)
 * Probably hard-coded to 11, see "generate.c"
 */
#define BLOCK_HGT	11

/**
 * Number of grids in each block (horizontally)
 * Probably hard-coded to 11, see "generate.c"
 */
#define BLOCK_WID	11


/**
 * Number of grids in each panel (vertically)
 */
#define PANEL_HGT	((int)(BLOCK_HGT / tile_height))

/**
 * Number of grids in each panel (horizontally)
 */
#define PANEL_WID       ((int)(BLOCK_WID / tile_width))


/**
 * Number of text rows in each map screen, regardless of tile size
 */
#define SCREEN_ROWS	(Term->hgt - ROW_MAP  - 1) 

/**
 * Number of grids in each screen (vertically)
 */
#define SCREEN_HGT    ((int) (SCREEN_ROWS / tile_height))

/**
 * Number of grids in each screen (horizontally)
 */
#define SCREEN_WID	((int)((Term->wid - COL_MAP - 1) / tile_width))

#define ROW_MAP			1
#define COL_MAP			13

/**
 * Number of grids in each dungeon (from top to bottom)
 * Must be a multiple of SCREEN_HGT
 * Must be less or equal to 256
 */
#define DUNGEON_HGT		66

/**
 * Number of grids in each dungeon (from left to right)
 * Must be a multiple of SCREEN_WID
 * Must be less or equal to 256
 */
#define DUNGEON_WID		198

/*
 * Radii for various detection spells. -BR-
 */
#define DETECT_RAD_DEFAULT      30
#define DETECT_RAD_MAP          255

/**
 * Maximum amount of Angband windows.
 */
#define ANGBAND_TERM_MAX 8


/**
 * Maximum number of player "sex" types (see "table.c", etc)
 */
#define MAX_SEXES            2

/*
 * Hack -- first normal and random artifact in the artifact list.  
 * All of the artifacts with indexes from 1 to 22 are special (lights, 
 * rings, amulets), the ones from 23 to 209 are normal, and the ones from 
 * 210 to 249 are random.
 */
#define ART_MIN_NORMAL		23
#define ART_MIN_RANDOM		210

/*
 * Number of tval/min-sval/max-sval slots per ego_item
 */
#define EGO_TVALS_MAX 3

/**
 * Maximum number of high scores in the high score file
 */
#define MAX_HISCORES	100


/**
 * OPTION: Maximum number of autoinscriptions(see "object1.c")
 */
#define AUTOINSCRIPTIONS_MAX 216

/**
 * Defines for graphics mode
 */

#define GRAPHICS_NONE           0


/* player_type.noscore flags */
#define NOSCORE_WIZARD		0x0002
#define NOSCORE_DEBUG		0x0008
#define NOSCORE_BORG		0x0010

/** 
 * Given an array, determine how many elements are in the array.
 */
#define N_ELEMENTS(a) (sizeof(a) / sizeof((a)[0]))


/**
 * Maximum value storable in a "byte" (hard-coded)

 #define MAX_UCHAR       255 */

/**
 * Maximum value storable in a "s16b" (hard-coded)
 
 #define MAX_SHORT       32767 */



/*** FAangband Themed Levels ***/

/**
 * No current theme (player is on a normal level)
 */
#define THEME_NONE		0

/*
 * Themed level indices.  Used to activate any theme-specific code. 
 * See generate.c for the table of themed level information.
 */
#define THEME_ELEMENTAL  1
#define THEME_DRAGON     2
#define THEME_WILDERNESS 3
#define THEME_DEMON      4
#define THEME_MINE       5
#define THEME_WARLORDS   6
#define THEME_AELUIN     7
#define THEME_ESTOLAD    8
#define THEME_SLAIN      9

/**
 * Current number of defined themes.  The maximum theoretical number is 32.
 */
#define THEME_MAX		9


/*
 * Store constants
 */
#define STORE_INVEN_MAX	24	/* Max number of discrete objs in inven */
#define STORE_CHOICES	32	/* Number of items to choose stock from */
#define STORE_OBJ_LEVEL	5	/* Magic Level for normal stores */
#define STORE_TURNOVER	9	/* Normal shop turnover, per day */
#define STORE_MIN_KEEP	6	/* Min slots to "always" keep full */
#define STORE_MAX_KEEP	18	/* Max slots to "always" keep full */
#define STORE_SHUFFLE	20	/* 1/Chance (per day) of an owner changing */
#define STORE_TURNS	1000	/* Number of turns between turnovers */


/**
 * Maximum dungeon level.  The player can never reach this level
 * in the dungeon, and this value is used for various calculations
 * involving object and monster creation.  It must be at least 100.
 * Setting it below 128 may prevent the creation of some objects.
 */
#define MAX_DEPTH	128


/*
 * Misc constants
 */
#define TOWN_DAWN	2000	/* Number of turns from dawn to dawn XXX */
#define BREAK_GLYPH	300	/* Rune of protection resistance */
#define BTH_PLUS_ADJ    1       /* Adjust BTH per plus-to-hit */
#define MON_MULT_ADJ	8	/* High value slows multiplication */
#define MON_SUMMON_ADJ	2	/* Adjust level of summoned creatures */
#define MON_DRAIN_LIFE	2	/* Percent of player exp drained per hit */
#define USE_DEVICE      3	/* x> Harder devices x< Easier devices     */

/**
 * Fraction of turns in which the extend magic special ability causes timers to
 * not decrement.
 */
#define EXTEND_MAGIC_FRACTION  3 /* Skip 3rd turn -> 50% longer durations */

/**
 * Amount of mana removed by Mana Burn specialty.
 */
#define BASE_MANA_BURN          20

/*
 * Refueling constants
 */
#define FUEL_TORCH	5000	/* Maximum amount of fuel in a torch */
#define FUEL_LAMP	15000   /* Maximum amount of fuel in a lantern */


/*
 * More maximum values
 */
#define MAX_SIGHT_LGE   20      /* Maximum view distance */
#define MAX_RANGE_LGE   20      /* Maximum projection range */
#define MAX_SIGHT_SML   10      /* Maximum view distance (small devices) */
#define MAX_RANGE_SML   10      /* Maximum projection range (small devices) */
#define MAX_SIGHT (MODE(SMALL_DEVICE) ? MAX_SIGHT_SML : MAX_SIGHT_LGE)  
#define MAX_RANGE (MODE(SMALL_DEVICE) ? MAX_RANGE_SML : MAX_RANGE_LGE)


/*** General index values ***/


/*
 * Indexes of the various "stats" (hard-coded by savefiles, etc).
 */
enum
{
	A_STR = 0,
	A_INT,
	A_WIS,
	A_DEX,
	A_CON,
	A_CHR,

	A_MAX
};



/*
 * Legal restrictions for "summon_specific()"
 */
#define SUMMON_KIN		 1
#define SUMMON_SAURON            2
#define SUMMON_ANT		11
#define SUMMON_SPIDER		12
#define SUMMON_HOUND		13
#define SUMMON_ANIMAL		14
#define SUMMON_SWAMP     	15
#define SUMMON_DEMON		16
#define SUMMON_UNDEAD		17
#define SUMMON_DRAGON		18
#define SUMMON_HI_DEMON		20
#define SUMMON_HI_UNDEAD	21
#define SUMMON_HI_DRAGON	22
#define SUMMON_WRAITH		31 /* now unused */
#define SUMMON_UNIQUE		32
#define SUMMON_ELEMENTAL	33
#define SUMMON_VORTEX		34
#define SUMMON_HYBRID		35
#define SUMMON_BIRD		36
#define SUMMON_GOLEM            37
#define SUMMON_THIEF		38


/*
 * Indexes for array of player incremental resists.
 */
#define P_RES_ACID		0
#define P_RES_ELEC		1
#define P_RES_FIRE		2
#define P_RES_COLD		3
#define P_RES_POIS		4
#define P_RES_LIGHT		5
#define P_RES_DARK		6
#define P_RES_CONFU		7
#define P_RES_SOUND		8
#define P_RES_SHARD		9
#define P_RES_NEXUS		10
#define P_RES_NETHR		11
#define P_RES_CHAOS		12
#define P_RES_DISEN		13
#define MAX_P_RES		14

/*
 * Indexes for array of player non-stat bonuses.
 */
#define P_BONUS_M_MASTERY       0
#define P_BONUS_STEALTH         1
#define P_BONUS_SEARCH          2
#define P_BONUS_INFRA           3
#define P_BONUS_TUNNEL          4
#define P_BONUS_SPEED           5
#define P_BONUS_SHOTS           6
#define P_BONUS_MIGHT           7
#define MAX_P_BONUS             8

/*
 * Indexes for array of player slay multiples.
 */
#define P_SLAY_ANIMAL           0
#define P_SLAY_EVIL             1
#define P_SLAY_UNDEAD           2
#define P_SLAY_DEMON            3
#define P_SLAY_ORC              4
#define P_SLAY_TROLL            5
#define P_SLAY_GIANT            6
#define P_SLAY_DRAGON           7
#define MAX_P_SLAY              8

/*
 * Indexes for array of player brand multiples.
 */
#define P_BRAND_ACID            0
#define P_BRAND_ELEC            1
#define P_BRAND_FIRE            2
#define P_BRAND_COLD            3
#define P_BRAND_POIS            4
#define MAX_P_BRAND             5

/*
 * Resistance limits - the number really means percentage damage taken -NRM-.
 */
#define RES_LEVEL_BASE		100
#define RES_LEVEL_MAX		200
#define RES_LEVEL_MIN		0

/*
 * Incremental resistance modifiers and caps.
 */
#define RES_BOOST_NORMAL	60
#define RES_BOOST_GREAT		45
#define RES_BOOST_IMMUNE	0
#define RES_BOOST_MINOR		75
#define RES_CUT_MINOR           130
#define RES_CUT_NORMAL          150
#define RES_CUT_GREAT           180
#define RES_CAP_EXTREME		75
#define RES_CAP_MODERATE	40
#define RES_CAP_ITEM            20

/* Defaults and modifiers for bonuses and multiples */
#define BONUS_BASE              0
#define MULTIPLE_BASE           10
#define SLAY_BOOST_SMALL        15  /* Slay Evil */
#define SLAY_BOOST_MINOR        17  /* Slay Animal */
#define SLAY_BOOST_NORMAL       20  /* Regular Slay */
#define SLAY_BOOST_KILL         25  /* Slay Kill */
#define BRAND_BOOST_NORMAL      17  /* Regular Brand */

/*
 * Some qualitative checks.
 */
#define p_resist_pos(X) \
   (p_ptr->state.res_list[X] < 100)
#define p_resist_good(X) \
   (p_ptr->state.res_list[X] <= 80)
#define p_resist_strong(X) \
   (p_ptr->state.res_list[X] <= 20)
#define p_immune(X) \
   (p_ptr->state.res_list[X] == 0)
#define p_vulnerable(X) \
   (p_ptr->state.res_list[X] > 100)

#define k_resist_pos(X) \
   (p_ptr->state.dis_res_list[X] < 100)
#define k_resist_good(X) \
   (p_ptr->state.dis_res_list[X] <= 80)
#define k_resist_strong(X) \
   (p_ptr->state.dis_res_list[X] <= 20)
#define k_immune(X) \
   (p_ptr->state.dis_res_list[X] == 0)
#define k_vulnerable(X) \
   (p_ptr->state.dis_res_list[X] > 100)

#define o_slay_weak(X, Y) \
   (X->multiple_slay[Y] < 10)
#define o_slay(X, Y) \
   (X->multiple_slay[Y] > 10)
#define o_kill(X, Y) \
   (X->multiple_slay[Y] > 20)

#define o_brand(X, Y) \
   (X->multiple_brand[Y] > 10)

/*
 * Some constants for the "learn" code.  These generalized from the
 * old DRS constants.
 */
#define LRN_FREE_SAVE	14
#define LRN_MANA	15
#define LRN_ACID	16
#define LRN_ELEC	17
#define LRN_FIRE	18
#define LRN_COLD	19
#define LRN_POIS	20
#define LRN_FEAR_SAVE	21
#define LRN_LIGHT	22
#define LRN_DARK	23
#define LRN_BLIND	24
#define LRN_CONFU	25
#define LRN_SOUND	26
#define LRN_SHARD	27
#define LRN_NEXUS	28
#define LRN_NETHR	29
#define LRN_CHAOS	30
#define LRN_DISEN	31
/* new in Oangband 0.5 and beyond */
#define LRN_DFIRE	38
#define LRN_SAVE        39
#define LRN_ARCH        40
#define LRN_PARCH       41
#define LRN_ICE         42
#define LRN_PLAS        43
#define LRN_SOUND2      44 /* attacks which aren't resisted, 
			    * but res sound prevent stun */
#define LRN_STORM       45
#define LRN_WATER       46
#define LRN_NEXUS_SAVE  47 /* Both resist Nexus and Saves apply */
#define LRN_BLIND_SAVE  48 /* Both resist Blind and Saves apply */
#define LRN_CONFU_SAVE  49 /* Both resist Confusion and Saves apply */
#define LRN_ALL         50 /* Recurses to all the resistables */

/*** Artifact indexes (see "lib/edit/a_info.txt") ***/

#define ART_MORGOTH		51
#define ART_UNGOLIANT           74
#define ART_GROND		158




/*** Ego-Item indexes (see "lib/edit/e_info.txt") ***/


/* Nothing */
/* xxx */
/* xxx */
/* xxx */

/* Body Armor */
#define EGO_RESIST_ACID		4
#define EGO_RESIST_ELEC		5
#define EGO_RESIST_FIRE		6
#define EGO_RESIST_COLD		7
#define EGO_RESISTANCE		8
#define EGO_ELVENKIND		9
#define EGO_DWARVEN		10
#define EGO_PERMANENCE		11
/* xxx */
/* xxx */
/* xxx */
/* xxx */

/* Shields */
#define EGO_ENDURE_ACID		16
#define EGO_ENDURE_ELEC		17
#define EGO_ENDURE_FIRE		18
#define EGO_ENDURE_COLD		19
#define EGO_ENDURANCE		20
#define EGO_NIGHT_DAY		21	/* Added in Oangband. */
/* xxx */
/* xxx */

/* Crowns and Helms */
#define EGO_INTELLIGENCE	24
#define EGO_WISDOM		25
#define EGO_BEAUTY		26
#define EGO_MAGI		27
#define EGO_MIGHT		28
#define EGO_LORDLINESS		29
#define EGO_SEEING		30
#define EGO_SERENITY		31	/* Changed in Oangband. */
#define EGO_LIGHT		32
#define EGO_TELEPATHY		33
#define EGO_REGENERATION	34
#define EGO_TELEPORTATION	35
#define EGO_STUPIDITY		36
#define EGO_NAIVETY		37
#define EGO_UGLINESS		38
#define EGO_SICKLINESS		39

/* Cloaks */
#define EGO_PROTECTION		40
#define EGO_STEALTH		41
#define EGO_AMAN		42
/* xxx */
#define EGO_ENVELOPING		44
#define EGO_VULNERABILITY	45
#define EGO_IRRITATION		46
#define EGO_SHARD_PROT		47	/* Added in Oangband. */

/* Gloves */
#define EGO_FREE_ACTION		48
#define EGO_SLAYING		49
#define EGO_AGILITY		50
#define EGO_POWER		51
#define EGO_MAGIC_MASTERY	52	/* Added in Oangband. */
/* xxx */
#define EGO_WEAKNESS		54
#define EGO_CLUMSINESS		55

/* Boots */
#define EGO_SLOW_DESCENT	56
#define EGO_QUIET		57
#define EGO_MOTION		58
#define EGO_SPEED		59
#define EGO_STABILITY		60	/* Added in Oangband. */
#define EGO_NOISE		61
#define EGO_SLOWNESS		62
#define EGO_TORMENT		63

/* Weapons */
#define EGO_HA			64
#define EGO_DORIATH		65
#define EGO_BLESS_BLADE		66
#define EGO_GONDOLIN            67
#define EGO_NOLDOR		68
#define EGO_NOGROD              69
/* xxx */
/* xxx */
#define EGO_BRAND_ACID		72
#define EGO_BRAND_ELEC		73
#define EGO_BRAND_FIRE		74
#define EGO_BRAND_COLD		75
#define EGO_BRAND_POIS		76	/* Added in Oangband. */
#define EGO_BALROG		77	/* Added in Oangband. */
/* xxx */
/* xxx */
#define EGO_SLAY_ANIMAL		80
#define EGO_SLAY_EVIL		81
#define EGO_SLAY_UNDEAD		82
#define EGO_SLAY_DEMON		83
#define EGO_SLAY_ORC		84
#define EGO_SLAY_TROLL		85
#define EGO_SLAY_GIANT		86
#define EGO_SLAY_DRAGON		87
#define EGO_KILL_ANIMAL		88
#define EGO_KILL_EVIL		89
#define EGO_KILL_UNDEAD		90
#define EGO_KILL_DEMON		83
#define EGO_KILL_ORC		84
#define EGO_KILL_TROLL		85
#define EGO_KILL_GIANT		86
#define EGO_KILL_DRAGON		95
/* xxx */
/* xxx */
/* xxx */
/* xxx */
#define EGO_DIGGING		100
/* xxx */
#define EGO_ANGBAND		102
/* xxx */

/* Bows */
#define EGO_ACCURACY		104
#define EGO_VELOCITY		105
#define EGO_OSSIRIAND           106
#define EGO_EXTRA_MIGHT 	107
/* xxx */
#define EGO_EXTRA_SHOTS		109
/* xxx */
/* xxx */

/* Ammo */
#define EGO_HURT_ANIMAL		111
#define EGO_HURT_EVIL		112
#define EGO_HURT_UNDEAD		113
#define EGO_HURT_DEMON		114
#define EGO_HURT_ORC		115
#define EGO_HURT_TROLL		116
#define EGO_HURT_GIANT		117
#define EGO_HURT_DRAGON		118
#define EGO_ACIDIC		119	/* Added in Oangband. */
#define EGO_ELECT		120	/* Added in Oangband. */
#define EGO_FLAME		121
#define EGO_FROST		122
#define EGO_POISON		123	/* Added in Oangband. */
#define EGO_WOUNDING		124
#define EGO_BACKBITING		125

/* Rings */
#define EGO_RING_ELEMENTS       128
#define EGO_RING_PHYSICAL       129
#define EGO_RING_COMBAT         130
#define EGO_RING_MOBILITY       131
#define EGO_RING_ARCANE_RES     132
#define EGO_RING_UTILITY        133
#define EGO_RING_BASIC_RES      134
#define EGO_RING_HINDRANCE      135
#define EGO_RING_DAWN           136
#define EGO_RING_SPEED          137
#define EGO_RING_WOE            138
#define EGO_RING_FICKLENESS     139
#define EGO_RING_POWER          140

/* Amulets */

#define EGO_AMULET_MENTAL       160
#define EGO_AMULET_DOOM         161
#define EGO_AMULET_BASIC_RES    162
#define EGO_AMULET_MAGIC_MAST   163
#define EGO_AMULET_CLARITY      164
#define EGO_AMULET_SHADOWS      165
#define EGO_AMULET_METAMORPH    166
#define EGO_AMULET_SUSTENANCE   167
#define EGO_AMULET_TRICKERY     168
#define EGO_AMULET_WEAPONMAST   169
#define EGO_AMULET_VITALITY     170
#define EGO_AMULET_INSIGHT      171


/*** Squelch stuff ***/

/** Number of bytes used in squelch sub-quality array - probably unnecessary */
#define SQUELCH_BYTES    6


/*** Monster blow constants ***/


#define MONSTER_BLOW_MAX 4

/*
 * Monster blow methods
 */
enum
{
	#define RBM(x, y) RBM_##x,
	#include "list-blow-methods.h"
	#undef RBM
	RBM_MAX
};

/*
 * Monster blow effects
 */
enum
{
	#define RBE(x, y) RBE_##x,
	#include "list-blow-effects.h"
	#undef RBE
	RBE_MAX
};

/** 1/x chance of reducing stats (for elemental attacks).  From Zangband
 * -LM-
 */
#define HURT_CHANCE	25


/*** Function flags ***/


#define PROJECT_NO          0
#define PROJECT_NOT_CLEAR   1
#define PROJECT_CLEAR       2

/*
 * Bit flags for the "target_set" function
 *
 *	KILL: Target monsters
 *	LOOK: Describe grid fully
 *	OBJ : Target objects
 *	GRID: Select from all grids
 */
#define TARGET_KILL	0x01
#define TARGET_LOOK	0x02
#define TARGET_OBJ	0x04
#define TARGET_GRID	0x08
#define TARGET_QUIET    0x10


/*
 * Bit flags for the "monster_desc" function
 */
#define MDESC_OBJE	0x01	/* Objective (or Reflexive) */
#define MDESC_POSS	0x02	/* Possessive (or Reflexive) */
#define MDESC_IND1	0x04	/* Indefinites for hidden monsters */
#define MDESC_IND2	0x08	/* Indefinites for visible monsters */
#define MDESC_PRO1	0x10	/* Pronominalize hidden monsters */
#define MDESC_PRO2	0x20	/* Pronominalize visible monsters */
#define MDESC_HIDE	0x40	/* Assume the monster is hidden */
#define MDESC_SHOW	0x80	/* Assume the monster is visible */


/*
 * Bit flags for the "get_item" function
 */
#define USE_EQUIP	0x01	/* Allow equip items */
#define USE_INVEN	0x02	/* Allow inven items */
#define USE_FLOOR	0x04	/* Allow floor items */
#define USE_TARGET	0x08	/* Allow targeted floor items */
#define CAN_SQUELCH	0x10	/* Allow selection of all squelched items */
#define IS_HARMLESS     0x20	/* Ignore generic warning inscriptions */
#define SHOW_PRICES     0x40	/* Show item prices in item lists */
#define SHOW_FAIL       0x80 	/* Show device failure in item lists */
#define QUIVER_TAGS     0x100  /* 0-9 are quiver slots when selecting */

/*** Player flags ***/


/*
 * Bit flags for the "p_ptr->notice" variable
 */
#define PN_COMBINE	0x00000001L	/* Combine the pack */
#define PN_REORDER	0x00000002L	/* Reorder the pack */
#define PN_AUTOINSCRIBE	0x00000004L	/* Autoinscribe items */
#define PN_PICKUP       0x00000008L	/* Pick stuff up */
#define PN_SQUELCH      0x00000010L	/* Squelch stuff */
#define PN_SORT_QUIVER  0x00000020L     /* Sort the quiver */
/* xxx (many) */


/*
 * Bit flags for the "p_ptr->update" variable
 */
#define PU_BONUS	0x00000001L	/* Calculate bonuses */
#define PU_TORCH	0x00000002L	/* Calculate torch radius */
/* xxx (many) */
#define PU_HP		0x00000010L	/* Calculate chp and mhp */
#define PU_MANA		0x00000020L	/* Calculate csp and msp */
#define PU_SPELLS	0x00000040L	/* Calculate spells */
#define PU_SPECIALTY	0x00000080L	/* Calculate specialties */
/* xxx (many) */
#define PU_FORGET_VIEW	0x00010000L	/* Forget field of view */
#define PU_UPDATE_VIEW	0x00020000L	/* Update field of view */
/* xxx (many) */
#define PU_MONSTERS	0x10000000L	/* Update monsters */
#define PU_DISTANCE	0x20000000L	/* Update distances */
/* xxx */
#define PU_PANEL	0x80000000L	/* Update panel */


/*
 * Bit flags for the "p_ptr->redraw" variable
 */
#define PR_MISC		0x00000001L	/* Display Race/Class */
#define PR_TITLE	0x00000002L	/* Display Title */
#define PR_LEV		0x00000004L	/* Display Level */
#define PR_EXP		0x00000008L	/* Display Experience */
#define PR_STATS	0x00000010L	/* Display Stats */
#define PR_ARMOR	0x00000020L	/* Display Armor */
#define PR_HP		0x00000040L	/* Display Hitpoints */
#define PR_MANA		0x00000080L	/* Display Mana */
#define PR_GOLD		0x00000100L	/* Display Gold */
#define PR_DEPTH	0x00000200L	/* Display Depth */
#define PR_SHAPE	0x00000400L	/* Display Shape.  -LM- */
#define PR_HEALTH	0x00000800L	/* Display Health Bar */
#define PR_INVEN	0x00001000L /* Display inven/equip */
#define PR_EQUIP	0x00002000L /* Display equip/inven */
#define PR_MESSAGE	0x00004000L /* Display messages */
#define PR_MONSTER	0x00008000L /* Display monster recall */
#define PR_OBJECT	0x00010000L /* Display object recall */
#define PR_MONLIST	0x00020000L /* Display monster list */

#define PR_ITEMLIST     0x00080000L /* Display item list */
#define PR_STATE	0x00100000L	/* Display Extra (State) */
#define PR_SPEED	0x00200000L	/* Display Extra (Speed) */
#define PR_STUDY	0x00400000L	/* Display Extra (Study) */
#define PR_DTRAP        0x00800000L     /* Display Extra (DTrap) */

#define PR_MON_MANA	0x04000000L	/* Display Mana Bar */
#define PR_MAP		0x08000000L	/* Display Map */
#define PR_WIPE         0x10000000L     /* Hack -- Total Redraw */

#define PR_STATUS	0x80000000L /* Display extra status messages */

/* Display Basic Info */
#define PR_BASIC \
	(PR_MISC | PR_TITLE | PR_STATS | PR_LEV |\
	 PR_EXP | PR_GOLD | PR_ARMOR | PR_HP |\
	 PR_MANA | PR_DEPTH | PR_HEALTH | PR_SPEED)

/* Display Extra Info */
#define PR_EXTRA \
	(PR_STATUS | PR_STATE | PR_STUDY)

/*
 * Bit flags for the "p_ptr->window" variable (etc)
 */
#define PW_INVEN	0x00000001L	/* Display inven/equip */
#define PW_EQUIP	0x00000002L	/* Display equip/inven */
#define PW_PLAYER_0	0x00000004L	/* Display player (basic) */
#define PW_PLAYER_1	0x00000008L	/* Display player (extra) */
#define PW_PLAYER_2     0x00000010L     /* Display player (compact) */
#define PW_MAP          0x00000020L     /* Display dungeon map */
#define PW_MESSAGE	0x00000040L	/* Display messages */
#define PW_OVERHEAD	0x00000080L	/* Display overhead view */
#define PW_MONSTER	0x00000100L	/* Display monster recall */
#define PW_OBJECT	0x00000200L	/* Display object recall */
#define PW_DUNGEON      0x00000400L     /* Display dungeon view */
#define PW_SNAPSHOT	0x00000800L	/* Display snap-shot */
#define PW_MONLIST      0x00001000L     /* Display monster list */
#define PW_ITEMLIST     0x00002000L     /* Display item list */
#define PW_BORG_1	0x00004000L	/* Display borg messages */
#define PW_BORG_2	0x00008000L	/* Display borg status */

#define PW_MAX_FLAGS		16

/*
 * Bit flags for the "p_ptr->special_attack" variable. -LM-
 *
 * Note:  The elemental and poison attacks should be managed using the 
 * function "set_ele_attack", in spell2.c.  This provides for timeouts and
 * prevents the player from getting more than one at a time.
 */
#define ATTACK_NORMAL           0x00000000
#define ATTACK_CONFUSE		0x00000001
#define ATTACK_BLKBRTH		0x00000002
#define ATTACK_FLEE		0x00000004
#define ATTACK_SUPERSHOT	0x00000008
#define ATTACK_ACID		0x00000010
#define ATTACK_ELEC		0x00000020
#define ATTACK_FIRE		0x00000040
#define ATTACK_COLD		0x00000080
#define ATTACK_POIS		0x00000100
#define ATTACK_HOLY		0x00000200

#define ATTACK_DRUID_CONFU	0x00010000

/* Special attack states that may be displayed on screen */
#define ATTACK_NOTICE		0x000003ff

/*
 * Values for shapechanges.  From Sangband.
 * As of FAangband 1.0.0 shapes must be consecutive
 */
#define SHAPE_NORMAL   0			/* Unaltered form. */
#define SHAPE_MOUSE    1
#define SHAPE_FERRET   2
#define SHAPE_HOUND    3
#define SHAPE_GAZELLE  4
#define SHAPE_LION     5
#define SHAPE_ENT      6
#define SHAPE_BAT      7
#define SHAPE_WEREWOLF 8
#define SHAPE_VAMPIRE  9
#define SHAPE_WYRM    10
#define SHAPE_BEAR    11
#define MAX_SHAPE     11

#define SCHANGE \
    (p_ptr->schange > 0 && p_ptr->schange < 12)



/*** Object flags ***/


/*
 * Chest trap flags (see "tables.c")
 */
#define CHEST_LOSE_STR		0x0001
#define CHEST_LOSE_CON		0x0002
#define CHEST_POISON		0x0004
#define CHEST_PARALYZE		0x0008
#define CHEST_EXPLODE		0x0010
#define CHEST_SUMMON		0x0020
#define CHEST_SCATTER		0x0040
#define CHEST_E_SUMMON		0x0080
#define CHEST_BIRD_STORM	0x0100
#define CHEST_H_SUMMON		0x0200
#define CHEST_RUNES_OF_EVIL	0x0400




/*
 * Game-generated feelings.  Used for inscriptions.
 */
#define FEEL_NONE              0
#define FEEL_DUBIOUS_STRONG    1
#define FEEL_PERILOUS          2
#define FEEL_DUBIOUS_WEAK      3
#define FEEL_AVERAGE           4
#define FEEL_GOOD_STRONG       5
#define FEEL_EXCELLENT         6
#define FEEL_GOOD_WEAK         7
#define FEEL_SPECIAL           8
#define FEEL_MAX               9


/*
 * Some bit-flags for the "smart" field
 *
 * Most of these relate to OF_* object flags or P_RES_* and percentage resists
 */
#define SM_RES_STRONG_ACID	0x00000001
#define SM_RES_STRONG_ELEC	0x00000002
#define SM_RES_STRONG_FIRE	0x00000004
#define SM_RES_STRONG_COLD	0x00000008
#define SM_RES_STRONG_POIS	0x00000010
#define SM_XXX1		        0x00000020
#define SM_XXX2		        0x00000040
#define SM_XXX3		        0x00000080
#define SM_GOOD_SAVE		0x00000100
#define SM_PERF_SAVE		0x00000200
#define SM_IMM_FREE		0x00000400
#define SM_IMM_MANA		0x00000800
#define SM_IMM_ACID		0x00001000
#define SM_IMM_ELEC		0x00002000
#define SM_IMM_FIRE		0x00004000
#define SM_IMM_COLD		0x00008000
#define SM_RES_ACID		0x00010000
#define SM_RES_ELEC		0x00020000
#define SM_RES_FIRE		0x00040000
#define SM_RES_COLD		0x00080000
#define SM_RES_POIS		0x00100000
#define SM_RES_FEAR		0x00200000
#define SM_RES_LIGHT		0x00400000
#define SM_RES_DARK		0x00800000
#define SM_RES_BLIND	        0x01000000
#define SM_RES_CONFU	        0x02000000
#define SM_RES_SOUND	        0x04000000
#define SM_RES_SHARD	        0x08000000
#define SM_RES_NEXUS	        0x10000000
#define SM_RES_NETHR	        0x20000000
#define SM_RES_CHAOS	        0x40000000
#define SM_RES_DISEN	        0x80000000

/*
 * Object flags
 */

enum
{
	#define OF(a,b) OF_##a,
	#include "list-object-flags.h"
	#undef OF
	OF_MAX
};

#define OF_SIZE                FLAG_SIZE(OF_MAX)

#define of_has(f, flag)        flag_has_dbg(f, OF_SIZE, flag, #f, #flag)
#define of_next(f, flag)       flag_next(f, OF_SIZE, flag)
#define of_is_empty(f)         flag_is_empty(f, OF_SIZE)
#define of_is_full(f)          flag_is_full(f, OF_SIZE)
#define of_is_inter(f1, f2)    flag_is_inter(f1, f2, OF_SIZE)
#define of_is_subset(f1, f2)   flag_is_subset(f1, f2, OF_SIZE)
#define of_is_equal(f1, f2)    flag_is_equal(f1, f2, OF_SIZE)
#define of_on(f, flag)         flag_on_dbg(f, OF_SIZE, flag, #f, #flag)
#define of_off(f, flag)        flag_off(f, OF_SIZE, flag)
#define of_wipe(f)             flag_wipe(f, OF_SIZE)
#define of_setall(f)           flag_setall(f, OF_SIZE)
#define of_negate(f)           flag_negate(f, OF_SIZE)
#define of_copy(f1, f2)        flag_copy(f1, f2, OF_SIZE)
#define of_union(f1, f2)       flag_union(f1, f2, OF_SIZE)
#define of_comp_union(f1, f2)  flag_comp_union(f1, f2, OF_SIZE)
#define of_inter(f1, f2)       flag_inter(f1, f2, OF_SIZE)
#define of_diff(f1, f2)        flag_diff(f1, f2, OF_SIZE)

#define OF_OBVIOUS_MASK \
  OF_THROWING, OF_TWO_HANDED_REQ, OF_TWO_HANDED_DES, OF_SHOW_MODS 

#define OF_PROOF_MASK \
  OF_ACID_PROOF, OF_ELEC_PROOF, OF_FIRE_PROOF,	OF_COLD_PROOF
 
/*
 * Curse flags
 */

enum
{
	#define CF(a,b) CF_##a,
	#include "list-curse-flags.h"
	#undef CF
	CF_MAX
};

#define CF_SIZE                FLAG_SIZE(CF_MAX)

#define cf_has(f, flag)        flag_has_dbg(f, CF_SIZE, flag, #f, #flag)
#define cf_next(f, flag)       flag_next(f, CF_SIZE, flag)
#define cf_is_empty(f)         flag_is_empty(f, CF_SIZE)
#define cf_is_full(f)          flag_is_full(f, CF_SIZE)
#define cf_is_inter(f1, f2)    flag_is_inter(f1, f2, CF_SIZE)
#define cf_is_subset(f1, f2)   flag_is_subset(f1, f2, CF_SIZE)
#define cf_is_equal(f1, f2)    flag_is_equal(f1, f2, CF_SIZE)
#define cf_on(f, flag)         flag_on_dbg(f, CF_SIZE, flag, #f, #flag)
#define cf_off(f, flag)        flag_off(f, CF_SIZE, flag)
#define cf_wipe(f)             flag_wipe(f, CF_SIZE)
#define cf_setall(f)           flag_setall(f, CF_SIZE)
#define cf_negate(f)           flag_negate(f, CF_SIZE)
#define cf_copy(f1, f2)        flag_copy(f1, f2, CF_SIZE)
#define cf_union(f1, f2)       flag_union(f1, f2, CF_SIZE)
#define cf_comp_union(f1, f2)  flag_comp_union(f1, f2, CF_SIZE)
#define cf_inter(f1, f2)       flag_inter(f1, f2, CF_SIZE)
#define cf_diff(f1, f2)        flag_diff(f1, f2, CF_SIZE)


/*
 * Kind flags
 */

enum
{
	#define KF(a,b) KF_##a,
	#include "list-kind-flags.h"
	#undef KF
	KF_MAX
};

#define KF_SIZE                FLAG_SIZE(KF_MAX)

#define kf_has(f, flag)        flag_has_dbg(f, KF_SIZE, flag, #f, #flag)
#define kf_next(f, flag)       flag_next(f, KF_SIZE, flag)
#define kf_is_empty(f)         flag_is_empty(f, KF_SIZE)
#define kf_is_full(f)          flag_is_full(f, KF_SIZE)
#define kf_is_inter(f1, f2)    flag_is_inter(f1, f2, KF_SIZE)
#define kf_is_subset(f1, f2)   flag_is_subset(f1, f2, KF_SIZE)
#define kf_is_equal(f1, f2)    flag_is_equal(f1, f2, KF_SIZE)
#define kf_on(f, flag)         flag_on_dbg(f, KF_SIZE, flag, #f, #flag)
#define kf_off(f, flag)        flag_off(f, KF_SIZE, flag)
#define kf_wipe(f)             flag_wipe(f, KF_SIZE)
#define kf_setall(f)           flag_setall(f, KF_SIZE)
#define kf_negate(f)           flag_negate(f, KF_SIZE)
#define kf_copy(f1, f2)        flag_copy(f1, f2, KF_SIZE)
#define kf_union(f1, f2)       flag_union(f1, f2, KF_SIZE)
#define kf_comp_union(f1, f2)  flag_comp_union(f1, f2, KF_SIZE)
#define kf_inter(f1, f2)       flag_inter(f1, f2, KF_SIZE)
#define kf_diff(f1, f2)        flag_diff(f1, f2, KF_SIZE)


/*
 * Identify flags
 */

enum
{
	#define IF(a,b) IF_##a,
	#include "list-identify-flags.h"
	#undef IF
	IF_MAX
};

#define IF_SIZE                FLAG_SIZE(IF_MAX)

#define if_has(f, flag)        flag_has_dbg(f, IF_SIZE, flag, #f, #flag)
#define if_next(f, flag)       flag_next(f, IF_SIZE, flag)
#define if_is_empty(f)         flag_is_empty(f, IF_SIZE)
#define if_is_full(f)          flag_is_full(f, IF_SIZE)
#define if_is_inter(f1, f2)    flag_is_inter(f1, f2, IF_SIZE)
#define if_is_subset(f1, f2)   flag_is_subset(f1, f2, IF_SIZE)
#define if_is_equal(f1, f2)    flag_is_equal(f1, f2, IF_SIZE)
#define if_on(f, flag)         flag_on_dbg(f, IF_SIZE, flag, #f, #flag)
#define if_off(f, flag)        flag_off(f, IF_SIZE, flag)
#define if_wipe(f)             flag_wipe(f, IF_SIZE)
#define if_setall(f)           flag_setall(f, IF_SIZE)
#define if_negate(f)           flag_negate(f, IF_SIZE)
#define if_copy(f1, f2)        flag_copy(f1, f2, IF_SIZE)
#define if_union(f1, f2)       flag_union(f1, f2, IF_SIZE)
#define if_comp_union(f1, f2)  flag_comp_union(f1, f2, IF_SIZE)
#define if_inter(f1, f2)       flag_inter(f1, f2, IF_SIZE)
#define if_diff(f1, f2)        flag_diff(f1, f2, IF_SIZE)




/*
 * Random object kind flag info (base flag value)
 */
#define OBJECT_RAND_BASE_SUSTAIN	OF_SUSTAIN_STR
#define OBJECT_RAND_BASE_POWER		OF_SLOW_DIGEST

/*
 * Random object kind flag info (number of flags)
 */
#define OBJECT_RAND_SIZE_SUSTAIN	6
#define OBJECT_RAND_SIZE_POWER		10

/* 
 * Object ID flag info (base flag value)
 */
#define OBJECT_ID_BASE_RESIST           IF_RES_ACID
#define OBJECT_ID_BASE_SLAY             IF_SLAY_ANIMAL
#define OBJECT_ID_BASE_BRAND            IF_BRAND_ACID

/*
 * Player race and class flags
 */

enum
{
#define PF(a, b, c, d) PF_##a
	#include "list-player-flags.h"
	#undef PF
	PF_MAX
};

#define PF_SIZE                FLAG_SIZE(PF_MAX)

enum
{
    PLAYER_FLAG_SPECIAL,
    PLAYER_FLAG_RACE,
    PLAYER_FLAG_CLASS
};

#define PF_NO_SPECIALTY		255


#define pf_has(f, flag)        flag_has_dbg(f, PF_SIZE, flag, #f, #flag)
#define pf_next(f, flag)       flag_next(f, PF_SIZE, flag)
#define pf_is_empty(f)         flag_is_empty(f, PF_SIZE)
#define pf_is_full(f)          flag_is_full(f, PF_SIZE)
#define pf_is_inter(f1, f2)    flag_is_inter(f1, f2, PF_SIZE)
#define pf_is_subset(f1, f2)   flag_is_subset(f1, f2, PF_SIZE)
#define pf_is_equal(f1, f2)    flag_is_equal(f1, f2, PF_SIZE)
#define pf_on(f, flag)         flag_on_dbg(f, PF_SIZE, flag, #f, #flag)
#define pf_off(f, flag)        flag_off(f, PF_SIZE, flag)
#define pf_wipe(f)             flag_wipe(f, PF_SIZE)
#define pf_setall(f)           flag_setall(f, PF_SIZE)
#define pf_negate(f)           flag_negate(f, PF_SIZE)
#define pf_copy(f1, f2)        flag_copy(f1, f2, PF_SIZE)
#define pf_union(f1, f2)       flag_union(f1, f2, PF_SIZE)
#define pf_comp_union(f1, f2)  flag_comp_union(f1, f2, PF_SIZE)
#define pf_inter(f1, f2)       flag_inter(f1, f2, PF_SIZE)
#define pf_diff(f1, f2)        flag_diff(f1, f2, PF_SIZE)

#define player_race_has(flag)        (pf_has(rp_ptr->pflags, (flag)))
#define player_class_has(flag)       (pf_has(cp_ptr->pflags, (flag)))
#define player_class_avail(flag)     (pf_has(cp_ptr->specialties, (flag)))
#define player_chose(flag)           (pf_has(p_ptr->pflags, (flag)))
#define player_has(flag)       (pf_has(rp_ptr->pflags, (flag)) || pf_has(cp_ptr->pflags, (flag)) || pf_has(p_ptr->pflags, (flag)))


/*** Macro Definitions ***/


/**
 * Hack -- The main "screen"
 */
#define term_screen	(angband_term[0])

/**
 * Some monster types are different.
 */
#define monster_is_unusual(R) \
	(flags_test((R)->flags, RF_SIZE, RF_DEMON, RF_UNDEAD, RF_STUPID, FLAG_END) || \
	strchr("Evg", (R)->d_char))

/**
 * Convert an "attr"/"char" pair into a "pict" (P)
 */
#define PICT(A,C) \
	((((u16b)(A)) << 8) | ((byte)(C)))

/**
 * Convert a "pict" (P) into an "attr" (A)
 */
#define PICT_A(P) \
	((byte)((P) >> 8))

/**
 * Convert a "pict" (P) into an "char" (C)
 */
#define PICT_C(P) \
	((char)((byte)(P)))


/**
 * Convert a "location" (Y,X) into a "grid" (G)
 */
#define GRID(Y,X) \
	(256 * (Y) + (X))

/**
 * Convert a "grid" (G) into a "location" (Y)
 */
#define GRID_Y(G) \
	((int)((G) / 256U))

/**
 * Convert a "grid" (G) into a "location" (X)
 */
#define GRID_X(G) \
	((int)((G) % 256U))


/**
 * Convert a "key event" into a "location" (Y)
 */
#define KEY_GRID_Y(K) \
  ((int) (((K.mouse.y - ROW_MAP) / tile_height) + Term->offset_y))

/**
 * Convert a "key event" into a "location" (X)
 */
#define KEY_GRID_X(K) \
	((int) (((K.mouse.x - COL_MAP) / tile_width) + Term->offset_x))

/**
 * Determines if a map location is "meaningful"
 */
#define in_bounds(Y,X) \
	(((unsigned)(Y) < (unsigned)(DUNGEON_HGT)) && \
	 ((unsigned)(X) < (unsigned)(DUNGEON_WID)))

/**
 * Determines if a map location is fully inside the outer walls
 * This is more than twice as expensive as "in_bounds()", but
 * often we need to exclude the outer walls from calculations.
 */
#define in_bounds_fully(Y,X) \
	(((Y) > 0) && ((Y) < DUNGEON_HGT-1) && \
	 ((X) > 0) && ((X) < DUNGEON_WID-1))


/**
 * Determines if a map location is currently "on screen"
 * Note that "panel_contains(Y,X)" always implies "in_bounds(Y,X)".
 * Pre-storing this into a cave_info flag would be nice.  XXX XXX
#define panel_contains(Y,X) \
	(((unsigned)((Y) - Term->offset_y) < (unsigned)(SCREEN_HGT)) && \
	 ((unsigned)((X) - Term->offset_x) < (unsigned)(SCREEN_WID)))
 */

/**
 * Determine if a legal grid can be projected through
 * This is a pretty feeble hack -NRM-
 */
#define cave_project(Y,X) \
    (tf_has(f_info[cave_feat[Y][X]].flags, TF_PROJECT)) 


/**
 * Determine if a legal grid is a clean floor grid
 * Used for placing objects
 *
 * Line 1 -- check can hold an object
 * Line 2 -- forbid normal objects
 */
#define cave_clean_bold(Y,X)		     \
    (tf_has(f_info[cave_feat[Y][X]].flags, TF_OBJECT) && \
     (cave_o_idx[Y][X] == 0))

/**
 * Determine if a legal grid is an empty floor grid
 * Used for safely placing the player or a monster
 *
 * Line 1 -- check easily passed through
 * Line 2 -- forbid player/monsters
 */
#define cave_empty_bold(Y,X) \
    (tf_has(f_info[cave_feat[Y][X]].flags, TF_EASY) && \
     (cave_m_idx[Y][X] == 0))

/**
 * Determine if a "legal" grid is within "los" of the player
 *
 * Note the use of comparison to zero to force a "boolean" result
 */
#define player_has_los_bold(Y,X) \
    (sqinfo_has(cave_info[Y][X], SQUARE_VIEW))


/**
 * Determine if a "legal" grid can be "seen" by the player
 *
 * Note the use of comparison to zero to force a "boolean" result
 */
#define player_can_see_bold(Y,X) \
    (sqinfo_has(cave_info[Y][X], SQUARE_SEEN))


/*
 * Hack -- Prepare to use the "Secure" routines
 */
#if defined(SET_UID) && defined(SECURE)
extern int PlayerUID;
# define getuid() PlayerUID
# define geteuid() PlayerUID
#endif



/*** Hack ***/

/*
 * Maximum number of macro trigger names
 */
#define MAX_MACRO_TRIGGER 200
#define MAX_MACRO_MOD 12



/**
 * Max number of terminal windows -CN-
 */
#define TERM_WIN_MAX 8

/**
 * Max number of lines of notes
 */
#define DUMP_MAX_LINES 5000

#define SCAN_INSTANT ((u32b) -1)
#define SCAN_OFF 0
#define SCAN_MACRO 45


/**
 * Sign of a non-racial monster
 */
#define NON_RACIAL 255

/** 
 * Maximum rune mana reserve 
 */
#define MAX_MANA_RESERVE 200

/** Max number of items in the itemlist */
#define MAX_ITEMLIST 256

/* MSVC doesn't have va_copy (which is C99) or an alternative, so we'll just
 * copy the SRC pointer. In other cases we'll use va_copy() as we should. */
#ifdef _MSC_VER
#define VA_COPY(DST, SRC) (DST) = (SRC)
#else
#define VA_COPY(DST, SRC) va_copy(DST, SRC)
#endif

#endif /* !INCLUDED_DEFINES_H */
